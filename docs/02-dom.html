<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 02: DOM Manipulation | EvolveU Documentation</title>
    <meta name="description" content="EvolveU Full-Stack Bootcamp Documentation">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="doc-style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;900&family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body class="doc-page">
    <!-- Navigation -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="index.html" style="display: flex; align-items: center; gap: 0.75rem; text-decoration: none; color: inherit;">
                    <span class="logo">üìö</span>
                    <span class="brand-text">EvolveU Docs</span>
                </a>
            </div>
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="INDEX.html" class="nav-link">All Modules</a>
                <a href="https://github.com/brennanbrown/evolveu" target="_blank" class="nav-link">GitHub</a>
                <a href="https://brennanbrown.ca" target="_blank" class="btn btn-primary">Portfolio</a>
            </div>
        </div>
    </nav>

    <div class="doc-container">
        <!-- Sidebar -->
        <aside class="doc-sidebar">
            <h3>Modules</h3>
            <nav class="doc-nav">
                <a href="00-testing.html" class="doc-nav-link">00 - Testing Fundamentals</a>
                <a href="01-getting-started.html" class="doc-nav-link">01 - Getting Started</a>
                <a href="02-dom.html" class="doc-nav-link">02 - DOM Manipulation</a>
                <a href="03-objects.html" class="doc-nav-link">03 - Objects & APIs</a>
                <a href="04-react.html" class="doc-nav-link">04 - React Applications</a>
                <a href="05-api.html" class="doc-nav-link">05 - Flask API Server</a>
                <a href="06-python.html" class="doc-nav-link">06 - Python Fundamentals</a>
                <a href="07-flask.html" class="doc-nav-link">07 - Flask Full-Stack</a>
            </nav>
            
            <h3 style="margin-top: 2rem;">Resources</h3>
            <nav class="doc-nav">
                <a href="README.html" class="doc-nav-link">Getting Started</a>
                <a href="INDEX.html" class="doc-nav-link">Documentation Index</a>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="doc-content">
            <article class="markdown-body">
<h1 id="module-02-dom-manipulation">Module 02: DOM Manipulation</h1>
<p><strong>Learning Focus:</strong> Document Object Model (DOM), dynamic
HTML manipulation, and programmatic UI updates</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ol type="1">
<li><a href="#module-overview">Module Overview</a></li>
<li><a href="#core-concepts">Core Concepts</a></li>
<li><a href="#code-walkthrough">Code Walkthrough</a></li>
<li><a href="#testing-strategy">Testing Strategy</a></li>
<li><a href="#bugs-fixed">Bugs Fixed</a></li>
<li><a href="#2021-vs-2025-comparison">2021 vs 2025 Comparison</a></li>
<li><a href="#key-takeaways">Key Takeaways</a></li>
</ol>
<hr />
<h2 id="module-overview">Module Overview</h2>
<h3 id="what-were-building">What We're Building</h3>
<p>This module introduces <strong>DOM manipulation</strong>‚Äîthe ability
to dynamically create, modify, and delete HTML elements using
JavaScript. We build helper functions that:</p>
<ul>
<li>Create new DOM elements</li>
<li>Insert elements before existing ones</li>
<li>Insert elements after existing ones</li>
<li>Append elements to containers</li>
</ul>
<h3 id="why-dom-manipulation-matters">Why DOM Manipulation Matters</h3>
<p>Every modern web application needs to update the UI dynamically:</p>
<ul>
<li><strong>Social Media</strong>: New posts appear without page
reload</li>
<li><strong>E-commerce</strong>: Shopping cart updates instantly</li>
<li><strong>Gmail</strong>: Emails load and display dynamically</li>
<li><strong>Google Maps</strong>: Map pins added/removed on-the-fly</li>
</ul>
<p>Without DOM manipulation, we'd need full page reloads for every
change‚Äîslow and jarring UX.</p>
<hr />
<h2 id="core-concepts">Core Concepts</h2>
<h3 id="1-what-is-the-dom">1. What is the DOM?</h3>
<p>The <strong>Document Object Model</strong> is a tree representation
of HTML:</p>
<pre class="html"><code>&lt;!-- HTML --&gt;
&lt;div id=&quot;container&quot;&gt;
    &lt;h1&gt;Title&lt;/h1&gt;
    &lt;p&gt;Content&lt;/p&gt;
&lt;/div&gt;</code></pre>
<pre><code>DOM Tree:
    div#container
    ‚îú‚îÄ‚îÄ h1 (Title)
    ‚îî‚îÄ‚îÄ p (Content)</code></pre>
<p>JavaScript can traverse and modify this tree:</p>
<pre class="javascript"><code>const container = document.getElementById(&#39;container&#39;);
container.innerHTML = &#39;&lt;h2&gt;New Title&lt;/h2&gt;&#39;;  // Modified!</code></pre>
<h3 id="2-creating-elements">2. Creating Elements</h3>
<pre class="javascript"><code>// Create a new element
const newDiv = document.createElement(&#39;div&#39;);

// Set attributes
newDiv.id = &#39;myDiv&#39;;
newDiv.className = &#39;card&#39;;

// Set content
newDiv.textContent = &#39;Hello World&#39;;
newDiv.innerHTML = &#39;&lt;strong&gt;Bold text&lt;/strong&gt;&#39;;

// Result:
// &lt;div id=&quot;myDiv&quot; class=&quot;card&quot;&gt;&lt;strong&gt;Bold text&lt;/strong&gt;&lt;/div&gt;</code></pre>
<h3 id="3-insertion-methods">3. Insertion Methods</h3>
<pre class="javascript"><code>const parent = document.getElementById(&#39;container&#39;);
const newElement = document.createElement(&#39;p&#39;);

// Method 1: Append to end
parent.appendChild(newElement);

// Method 2: Insert before specific child
const referenceElement = parent.children[0];
parent.insertBefore(newElement, referenceElement);

// Method 3: Insert after (no native method!)
// This is why we build our own helper functions</code></pre>
<h3 id="4-selecting-elements">4. Selecting Elements</h3>
<pre class="javascript"><code>// By ID (returns single element)
const el = document.getElementById(&#39;myId&#39;);

// By class (returns collection)
const els = document.getElementsByClassName(&#39;myClass&#39;);

// By CSS selector (returns first match)
const el = document.querySelector(&#39;.myClass&#39;);

// By CSS selector (returns all matches)
const els = document.querySelectorAll(&#39;.myClass&#39;);</code></pre>
<hr />
<h2 id="code-walkthrough">Code Walkthrough</h2>
<h3 id="file-structure">File Structure</h3>
<pre><code>02-dom/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ dom.js          # DOM manipulation functions
‚îÇ   ‚îú‚îÄ‚îÄ dom.test.js     # Tests using jsdom
‚îÇ   ‚îî‚îÄ‚îÄ index.html      # Visual testing page
‚îú‚îÄ‚îÄ jest.config.js      # Configure jsdom environment
‚îî‚îÄ‚îÄ package.json</code></pre>
<h3 id="domjs---core-dom-functions">dom.js - Core DOM Functions</h3>
<pre class="javascript"><code>const domFunctions = {
    /**
     * Get a DOM element by ID
     * @param {string} id - The element ID
     * @returns {HTMLElement} The DOM element
     */
    getById: (id) =&gt; {
        return document.getElementById(id);
    },

    /**
     * Create a new DOM element
     * @param {string} type - Element type (div, p, span, etc.)
     * @returns {HTMLElement} New element
     */
    createNewDomElement: (type) =&gt; {
        return document.createElement(type);
    },

    /**
     * Set text content of an element
     * @param {HTMLElement} element - Target element
     * @param {string} text - Text to set
     * @returns {HTMLElement} The modified element
     */
    changeText: (element, text) =&gt; {
        element.textContent = text;
        return element;
    },

    /**
     * Set ID attribute of an element
     * @param {HTMLElement} element - Target element
     * @param {string} id - ID to set
     * @returns {HTMLElement} The modified element
     */
    changeId: (element, id) =&gt; {
        element.id = id;
        return element;
    },

    /**
     * Add a class to an element
     * @param {HTMLElement} element - Target element
     * @param {string} className - Class to add
     * @returns {HTMLElement} The modified element
     */
    addClass: (element, className) =&gt; {
        element.classList.add(className);
        return element;
    },

    /**
     * Insert element BEFORE a reference element
     * @param {HTMLElement} newElement - Element to insert
     * @param {HTMLElement} referenceElement - Existing element
     */
    addBefore: (newElement, referenceElement) =&gt; {
        // ‚ö†Ô∏è BUG WAS HERE: Logic was swapped with addAfter
        referenceElement.parentNode.insertBefore(
            newElement,
            referenceElement
        );
    },

    /**
     * Insert element AFTER a reference element
     * @param {HTMLElement} newElement - Element to insert
     * @param {HTMLElement} referenceElement - Existing element
     */
    addAfter: (newElement, referenceElement) =&gt; {
        // ‚ö†Ô∏è BUG WAS HERE: Logic was swapped with addBefore
        referenceElement.parentNode.insertBefore(
            newElement,
            referenceElement.nextSibling
        );
    },

    /**
     * Append element as last child of parent
     * @param {HTMLElement} newElement - Element to add
     * @param {HTMLElement} parentElement - Parent container
     */
    addLast: (newElement, parentElement) =&gt; {
        parentElement.appendChild(newElement);
    }
};

export default domFunctions;</code></pre>
<p><strong>Key Design Decisions:</strong></p>
<ol type="1">
<li><p><strong>Why return the element?</strong></p>
<pre class="javascript"><code>// Allows method chaining
domFunctions.createNewDomElement(&#39;div&#39;)
    .changeText(element, &#39;Hello&#39;)
    .addClass(element, &#39;card&#39;);</code></pre></li>
<li><p><strong>Why <code>insertBefore</code> for
<code>addAfter</code>?</strong></p>
<ul>
<li>JavaScript has <code>insertBefore()</code> but no
<code>insertAfter()</code></li>
<li>We simulate <code>addAfter</code> by inserting before the
<code>nextSibling</code></li>
</ul>
<pre class="javascript"><code>// Insert after means: insert before the next element
parent.insertBefore(newEl, referenceEl.nextSibling);</code></pre></li>
<li><p><strong>Why use <code>classList.add()</code>?</strong></p>
<pre class="javascript"><code>// ‚úÖ GOOD: Preserves existing classes
element.classList.add(&#39;new-class&#39;);

// ‚ùå BAD: Overwrites existing classes
element.className = &#39;new-class&#39;;</code></pre></li>
</ol>
<hr />
<h2 id="testing-strategy">Testing Strategy</h2>
<h3 id="jestconfigjs---setting-up-jsdom">jest.config.js - Setting Up
jsdom</h3>
<pre class="javascript"><code>module.exports = {
  testEnvironment: &#39;jsdom&#39;,  // Simulate browser DOM
  transform: {
    &#39;^.+\\.jsx?$&#39;: &#39;babel-jest&#39;,
  }
};</code></pre>
<p><strong>Why jsdom?</strong></p>
<ul>
<li>Jest runs in Node.js (no browser)</li>
<li>jsdom creates a fake DOM in memory</li>
<li>We can test DOM operations without opening a browser</li>
</ul>
<h3 id="domtestjs---test-suite">dom.test.js - Test Suite</h3>
<pre class="javascript"><code>import domFunctions from &quot;./dom.js&quot;;

test(&quot;Does the dom functions work?&quot;, () =&gt; {
    // Create container element
    const parent = domFunctions.createNewDomElement(&#39;div&#39;);
    domFunctions.changeId(parent, &#39;parent&#39;);
    
    // Create first child
    const first = domFunctions.createNewDomElement(&#39;p&#39;);
    domFunctions.changeText(first, &#39;First&#39;);
    domFunctions.changeId(first, &#39;first&#39;);
    
    // Append first child to parent
    domFunctions.addLast(first, parent);
    
    // Verify structure
    expect(parent.id).toBe(&#39;parent&#39;);
    expect(parent.children.length).toBe(1);
    expect(parent.children[0].textContent).toBe(&#39;First&#39;);
});

test(&quot;Does the addBefore function work?&quot;, () =&gt; {
    // Setup: parent with one child
    const parent = domFunctions.createNewDomElement(&#39;div&#39;);
    const existing = domFunctions.createNewDomElement(&#39;p&#39;);
    domFunctions.changeId(existing, &#39;existing&#39;);
    domFunctions.addLast(existing, parent);
    
    // Add new element BEFORE existing
    const newElement = domFunctions.createNewDomElement(&#39;span&#39;);
    domFunctions.changeId(newElement, &#39;new&#39;);
    domFunctions.addBefore(newElement, existing);
    
    // Verify order
    expect(parent.children.length).toBe(2);
    expect(parent.children[0].id).toBe(&#39;new&#39;);      // New is first
    expect(parent.children[1].id).toBe(&#39;existing&#39;); // Existing is second
});

test(&quot;Does the after function work?&quot;, () =&gt; {
    // Setup: parent with one child
    const parent = domFunctions.createNewDomElement(&#39;div&#39;);
    const existing = domFunctions.createNewDomElement(&#39;p&#39;);
    domFunctions.changeId(existing, &#39;existing&#39;);
    domFunctions.addLast(existing, parent);
    
    // Add new element AFTER existing
    const newElement = domFunctions.createNewDomElement(&#39;span&#39;);
    domFunctions.changeId(newElement, &#39;new&#39;);
    domFunctions.addAfter(newElement, existing);
    
    // Verify order
    expect(parent.children.length).toBe(2);
    expect(parent.children[0].id).toBe(&#39;existing&#39;); // Existing is first
    expect(parent.children[1].id).toBe(&#39;new&#39;);      // New is second
});</code></pre>
<p><strong>Testing Philosophy:</strong></p>
<p>Each test follows the <strong>Arrange-Act-Assert</strong>
pattern:</p>
<ol type="1">
<li><strong>Arrange</strong>: Set up DOM structure</li>
<li><strong>Act</strong>: Perform DOM operation</li>
<li><strong>Assert</strong>: Verify expected outcome</li>
</ol>
<hr />
<h2 id="bugs-fixed">Bugs Fixed</h2>
<h3 id="bug-1-import-path-typo">Bug #1: Import Path Typo</h3>
<pre class="javascript"><code>// ‚ùå WRONG: Incorrect filename
import domFunctions from &quot;./domfunc.js&quot;;

// ‚úÖ CORRECT: Match actual filename
import domFunctions from &quot;./dom.js&quot;;</code></pre>
<p><strong>Impact:</strong> Tests couldn't find the module, all tests
failed to run.</p>
<p><strong>How it happened:</strong> Likely a typo when creating the
test file.</p>
<p><strong>Lesson:</strong> Always verify import paths match actual file
names.</p>
<h3 id="bug-2-addbeforeaddafter-logic-swapped">Bug #2:
addBefore/addAfter Logic Swapped</h3>
<p>This was the most interesting bug‚Äîthe logic was completely
backwards!</p>
<pre class="javascript"><code>// ‚ùå WRONG: Functions did the opposite of their names
addBefore: (newElement, referenceElement) =&gt; {
    // This actually inserts AFTER!
    referenceElement.parentNode.insertBefore(
        newElement,
        referenceElement.nextSibling
    );
},

addAfter: (newElement, referenceElement) =&gt; {
    // This actually inserts BEFORE!
    referenceElement.parentNode.insertBefore(
        newElement,
        referenceElement
    );
}

// ‚úÖ CORRECT: Swap the implementations
addBefore: (newElement, referenceElement) =&gt; {
    referenceElement.parentNode.insertBefore(
        newElement,
        referenceElement
    );
},

addAfter: (newElement, referenceElement) =&gt; {
    referenceElement.parentNode.insertBefore(
        newElement,
        referenceElement.nextSibling
    );
}</code></pre>
<p><strong>Visual representation of the bug:</strong></p>
<pre><code>Before Bug Fix:
Called addBefore() ‚Üí Element appears AFTER
Called addAfter() ‚Üí Element appears BEFORE

After Bug Fix:
Called addBefore() ‚Üí Element appears BEFORE ‚úì
Called addAfter() ‚Üí Element appears AFTER ‚úì</code></pre>
<p><strong>How to avoid this:</strong></p>
<ol type="1">
<li>Write tests first (TDD)</li>
<li>Use descriptive variable names</li>
<li>Add comments explaining the logic</li>
</ol>
<hr />
<h2 id="2021-vs-2025-comparison">2021 vs 2025 Comparison</h2>
<h3 id="dom-manipulation-approaches">DOM Manipulation Approaches</h3>
<p><strong>2021: Direct DOM Manipulation</strong></p>
<pre class="javascript"><code>// Old way - direct HTML strings
const container = document.getElementById(&#39;app&#39;);
container.innerHTML = `
    &lt;div class=&quot;card&quot;&gt;
        &lt;h2&gt;${title}&lt;/h2&gt;
        &lt;p&gt;${description}&lt;/p&gt;
    &lt;/div&gt;
`;</code></pre>
<p><strong>Problems with 2021 approach:</strong></p>
<ul>
<li>‚ùå Security risk (XSS attacks)</li>
<li>‚ùå Loses event listeners</li>
<li>‚ùå Destroys existing elements</li>
<li>‚ùå No type safety</li>
</ul>
<p><strong>2025: Programmatic DOM Creation</strong></p>
<pre class="javascript"><code>// Modern way - create elements programmatically
const card = document.createElement(&#39;div&#39;);
card.className = &#39;card&#39;;

const title = document.createElement(&#39;h2&#39;);
title.textContent = titleText;  // Safe from XSS

const desc = document.createElement(&#39;p&#39;);
desc.textContent = descriptionText;

card.appendChild(title);
card.appendChild(desc);
container.appendChild(card);</code></pre>
<p><strong>Benefits of 2025 approach:</strong></p>
<ul>
<li>‚úÖ XSS-safe (textContent escapes HTML)</li>
<li>‚úÖ Preserves event listeners</li>
<li>‚úÖ Fine-grained control</li>
<li>‚úÖ Better for testing</li>
</ul>
<h3 id="modern-frameworks-reactvue">Modern Frameworks (React/Vue)</h3>
<p><strong>Why we still learn vanilla DOM:</strong> Even though React
exists, understanding the DOM is crucial:</p>
<pre class="jsx"><code>// React abstracts DOM manipulation
function Card({ title, description }) {
    return (
        &lt;div className=&quot;card&quot;&gt;
            &lt;h2&gt;{title}&lt;/h2&gt;
            &lt;p&gt;{description}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
<p><strong>But React compiles to:</strong></p>
<pre class="javascript"><code>// Similar to what we write manually!
React.createElement(&#39;div&#39;, { className: &#39;card&#39; },
    React.createElement(&#39;h2&#39;, null, title),
    React.createElement(&#39;p&#39;, null, description)
);</code></pre>
<p>Understanding vanilla DOM helps you:</p>
<ul>
<li>Debug React issues</li>
<li>Optimize performance</li>
<li>Work with web components</li>
<li>Understand what frameworks do under the hood</li>
</ul>
<h3 id="testing-evolution">Testing Evolution</h3>
<p><strong>2021: Manual Browser Testing</strong></p>
<pre class="javascript"><code>// Old way - open browser, look at page
function testAddBefore() {
    const parent = document.getElementById(&#39;test-container&#39;);
    const existing = parent.children[0];
    const newEl = document.createElement(&#39;span&#39;);
    addBefore(newEl, existing);
    
    // Manually inspect page in browser
    console.log(&#39;Check if span is before existing element&#39;);
}</code></pre>
<p><strong>2025: Automated jsdom Testing</strong></p>
<pre class="javascript"><code>// Modern way - automated tests
test(&quot;addBefore inserts element correctly&quot;, () =&gt; {
    const parent = document.createElement(&#39;div&#39;);
    const existing = document.createElement(&#39;p&#39;);
    parent.appendChild(existing);
    
    const newEl = document.createElement(&#39;span&#39;);
    addBefore(newEl, existing);
    
    // Automated assertion
    expect(parent.children[0]).toBe(newEl);
    expect(parent.children[1]).toBe(existing);
});</code></pre>
<hr />
<h2 id="key-takeaways">Key Takeaways</h2>
<h3 id="core-skills-developed">Core Skills Developed</h3>
<ol type="1">
<li><p><strong>DOM Tree Navigation</strong></p>
<pre class="javascript"><code>element.parentNode        // Go up
element.children          // Go down
element.nextSibling       // Go right
element.previousSibling   // Go left</code></pre></li>
<li><p><strong>Element Creation Pipeline</strong></p>
<pre class="javascript"><code>Create ‚Üí Configure ‚Üí Insert</code></pre></li>
<li><p><strong>Safe Content Updates</strong></p>
<pre class="javascript"><code>// ‚úÖ Safe from XSS
element.textContent = userInput;

// ‚ùå Dangerous!
element.innerHTML = userInput;</code></pre></li>
<li><p><strong>Testing DOM Code</strong></p>
<ul>
<li>Use jsdom for unit tests</li>
<li>Create minimal DOM structures</li>
<li>Test insertion order carefully</li>
</ul></li>
</ol>
<h3 id="common-patterns">Common Patterns</h3>
<p><strong>Pattern 1: Builder Functions</strong></p>
<pre class="javascript"><code>function createCard(title, content) {
    const card = document.createElement(&#39;div&#39;);
    card.className = &#39;card&#39;;
    
    const h2 = document.createElement(&#39;h2&#39;);
    h2.textContent = title;
    
    const p = document.createElement(&#39;p&#39;);
    p.textContent = content;
    
    card.appendChild(h2);
    card.appendChild(p);
    
    return card;
}</code></pre>
<p><strong>Pattern 2: Bulk Operations</strong></p>
<pre class="javascript"><code>// Create multiple elements efficiently
const items = [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Cherry&#39;];
const fragment = document.createDocumentFragment();

items.forEach(item =&gt; {
    const li = document.createElement(&#39;li&#39;);
    li.textContent = item;
    fragment.appendChild(li);
});

// Single reflow/repaint
list.appendChild(fragment);</code></pre>
<p><strong>Pattern 3: Template Cloning</strong></p>
<pre class="javascript"><code>// Clone template instead of creating from scratch
const template = document.getElementById(&#39;card-template&#39;);
const clone = template.content.cloneNode(true);
clone.querySelector(&#39;.title&#39;).textContent = &#39;New Title&#39;;
container.appendChild(clone);</code></pre>
<h3 id="performance-considerations">Performance Considerations</h3>
<p><strong>Minimize Reflows:</strong></p>
<pre class="javascript"><code>// ‚ùå BAD: Multiple reflows
for (let i = 0; i &lt; 1000; i++) {
    const li = document.createElement(&#39;li&#39;);
    list.appendChild(li);  // Reflow every time!
}

// ‚úÖ GOOD: Single reflow
const fragment = document.createDocumentFragment();
for (let i = 0; i &lt; 1000; i++) {
    const li = document.createElement(&#39;li&#39;);
    fragment.appendChild(li);
}
list.appendChild(fragment);  // One reflow</code></pre>
<p><strong>Batch Style Changes:</strong></p>
<pre class="javascript"><code>// ‚ùå BAD: Multiple style recalculations
element.style.width = &#39;100px&#39;;   // Recalc
element.style.height = &#39;200px&#39;;  // Recalc
element.style.color = &#39;red&#39;;     // Recalc

// ‚úÖ GOOD: Single recalculation
element.style.cssText = &#39;width: 100px; height: 200px; color: red;&#39;;</code></pre>
<hr />
<h2 id="further-learning">Further Learning</h2>
<h3 id="practice-exercises">Practice Exercises</h3>
<ol type="1">
<li><p><strong>Dynamic List Builder:</strong></p>
<ul>
<li>Create function that builds unordered list from array</li>
<li>Add click handlers to each item</li>
<li>Implement delete functionality</li>
</ul></li>
<li><p><strong>Table Generator:</strong></p>
<ul>
<li>Create table from 2D array</li>
<li>Add sorting by column</li>
<li>Implement cell editing</li>
</ul></li>
<li><p><strong>Modal Creator:</strong></p>
<ul>
<li>Build reusable modal component</li>
<li>Add open/close animations</li>
<li>Handle keyboard (ESC to close)</li>
</ul></li>
</ol>
<h3 id="real-world-applications">Real-World Applications</h3>
<ul>
<li><strong>Todo Lists</strong>: Add/remove/edit items dynamically</li>
<li><strong>Forms</strong>: Add form fields on demand</li>
<li><strong>Galleries</strong>: Load images dynamically</li>
<li><strong>Comments</strong>: Add new comments without page reload</li>
<li><strong>Notifications</strong>: Show toast messages</li>
</ul>
<h3 id="recommended-resources">Recommended Resources</h3>
<ul>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">MDN
DOM API</a></li>
<li><a href="https://javascript.info/document">JavaScript.info -
Document</a></li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web
Components</a></li>
</ul>
<h3 id="next-steps">Next Steps</h3>
<p>Now that we understand DOM manipulation, we're ready for
<strong>object-oriented programming</strong> and <strong>API
integration</strong> in <a href="./03-objects.md">Module 03: Objects
&amp; API Integration</a> ‚Üí</p>
<hr />
<p><strong>Module Status:</strong> ‚úÖ Complete (3/3 tests passing)<br />
<strong>Key Bugs Fixed:</strong> 2 (import path, swapped logic)<br />
<strong>Time Investment:</strong> ~2 hours<br />
<strong>Key Skill:</strong> Understanding the foundation that powers all
frontend frameworks</p>
            </article>
        </main>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-grid">
                <div class="footer-col">
                    <h4>EvolveU Documentation</h4>
                    <p>Comprehensive full-stack web development bootcamp documentation.</p>
                </div>
                <div class="footer-col">
                    <h4>Links</h4>
                    <ul class="footer-links">
                        <li><a href="https://brennanbrown.ca" target="_blank">Portfolio</a></li>
                        <li><a href="https://brennanbrown.ca/Resume.pdf" target="_blank">Resume</a></li>
                        <li><a href="https://github.com/brennanbrown" target="_blank">GitHub</a></li>
                        <li><a href="https://berryhouse.ca" target="_blank">BerryHouse</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Brennan Brown. Built with ‚ù§Ô∏è for the developer community.</p>
            </div>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="script.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
