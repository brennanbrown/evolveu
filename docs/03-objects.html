<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 03: Objects TITLE_PLACEHOLDER APIs | EvolveU Documentation</title>
    <meta name="description" content="EvolveU Full-Stack Bootcamp Documentation">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="doc-style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;900&family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>
<body class="doc-page">
    <!-- Navigation -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="index.html" style="display: flex; align-items: center; gap: 0.75rem; text-decoration: none; color: inherit;">
                    <span class="logo">üìö</span>
                    <span class="brand-text">EvolveU Docs</span>
                </a>
            </div>
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="INDEX.html" class="nav-link">All Modules</a>
                <a href="https://github.com/brennanbrown/evolveu" target="_blank" class="nav-link">GitHub</a>
                <a href="https://brennanbrown.ca" target="_blank" class="btn btn-primary">Portfolio</a>
            </div>
        </div>
    </nav>

    <div class="doc-container">
        <!-- Sidebar -->
        <aside class="doc-sidebar">
            <h3>Modules</h3>
            <nav class="doc-nav">
                <a href="00-testing.html" class="doc-nav-link">00 - Testing Fundamentals</a>
                <a href="01-getting-started.html" class="doc-nav-link">01 - Getting Started</a>
                <a href="02-dom.html" class="doc-nav-link">02 - DOM Manipulation</a>
                <a href="03-objects.html" class="doc-nav-link">03 - Objects & APIs</a>
                <a href="04-react.html" class="doc-nav-link">04 - React Applications</a>
                <a href="05-api.html" class="doc-nav-link">05 - Flask API Server</a>
                <a href="06-python.html" class="doc-nav-link">06 - Python Fundamentals</a>
                <a href="07-flask.html" class="doc-nav-link">07 - Flask Full-Stack</a>
            </nav>
            
            <h3 style="margin-top: 2rem;">Resources</h3>
            <nav class="doc-nav">
                <a href="README.html" class="doc-nav-link">Getting Started</a>
                <a href="INDEX.html" class="doc-nav-link">Documentation Index</a>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="doc-content">
            <article class="markdown-body">
<h1 id="module-03-objects--api-integration">Module 03: Objects &amp; API
Integration</h1>
<p><strong>Learning Focus:</strong> Object-Oriented Programming (OOP),
REST APIs, async/await, and full-stack integration</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ol type="1">
<li><a href="#module-overview">Module Overview</a></li>
<li><a href="#core-concepts">Core Concepts</a></li>
<li><a href="#code-walkthrough">Code Walkthrough</a></li>
<li><a href="#api-integration">API Integration</a></li>
<li><a href="#testing-strategy">Testing Strategy</a></li>
<li><a href="#bugs-fixed">Bugs Fixed</a></li>
<li><a href="#2021-vs-2025-comparison">2021 vs 2025 Comparison</a></li>
<li><a href="#key-takeaways">Key Takeaways</a></li>
</ol>
<hr />
<h2 id="module-overview">Module Overview</h2>
<h3 id="what-were-building">What We're Building</h3>
<p>This module represents a major milestone: <strong>building a
full-stack application</strong>. We create:</p>
<ol type="1">
<li><strong>Bank Account System</strong> - OOP with classes and
methods</li>
<li><strong>Geography/City Management</strong> - Complex class
hierarchies</li>
<li><strong>REST API Client</strong> - Fetch data from Flask
backend</li>
<li><strong>Integration Tests</strong> - Full client-server testing</li>
</ol>
<h3 id="why-this-matters">Why This Matters</h3>
<p>This is where everything comes together:</p>
<ul>
<li><strong>OOP</strong>: Organize code like real-world objects</li>
<li><strong>APIs</strong>: Communicate between frontend and backend</li>
<li><strong>Async/Await</strong>: Handle asynchronous operations
elegantly</li>
<li><strong>Full-Stack</strong>: Frontend (JavaScript) ‚ÜîÔ∏é Backend
(Flask/Python)</li>
</ul>
<h3 id="module-statistics">Module Statistics</h3>
<ul>
<li><strong>30 tests total</strong> (largest test suite yet!)</li>
<li><strong>14 bugs fixed</strong> during audit</li>
<li><strong>3 main classes</strong>: Account, City, Community</li>
<li><strong>5 API endpoints</strong>: /add, /all, /read, /update,
/delete, /clear</li>
</ul>
<hr />
<h2 id="core-concepts">Core Concepts</h2>
<h3 id="1-object-oriented-programming-oop">1. Object-Oriented
Programming (OOP)</h3>
<p><strong>What is a Class?</strong> A class is a blueprint for creating
objects:</p>
<pre class="javascript"><code>// Class definition (blueprint)
class Car {
    constructor(make, model, year) {
        this.make = make;
        this.model = model;
        this.year = year;
    }
    
    describe() {
        return `${this.year} ${this.make} ${this.model}`;
    }
}

// Creating instances (actual objects)
const myCar = new Car(&#39;Honda&#39;, &#39;Civic&#39;, 2020);
const yourCar = new Car(&#39;Toyota&#39;, &#39;Camry&#39;, 2021);

console.log(myCar.describe());  // &quot;2020 Honda Civic&quot;</code></pre>
<p><strong>The Four Pillars of OOP:</strong></p>
<ol type="1">
<li><p><strong>Encapsulation</strong>: Bundle data with methods</p>
<pre class="javascript"><code>class BankAccount {
    #balance = 0;  // Private field
    
    deposit(amount) {
        this.#balance += amount;  // Controlled access
    }
}</code></pre></li>
<li><p><strong>Inheritance</strong>: Reuse code from parent classes</p>
<pre class="javascript"><code>class SavingsAccount extends BankAccount {
    constructor(interestRate) {
        super();  // Call parent constructor
        this.interestRate = interestRate;
    }
}</code></pre></li>
<li><p><strong>Polymorphism</strong>: Different classes, same
interface</p>
<pre class="javascript"><code>class Cat {
    speak() { return &quot;Meow&quot;; }
}

class Dog {
    speak() { return &quot;Woof&quot;; }
}

[new Cat(), new Dog()].forEach(animal =&gt; {
    console.log(animal.speak());  // Different behavior, same method
});</code></pre></li>
<li><p><strong>Abstraction</strong>: Hide complexity, show only
essentials</p>
<pre class="javascript"><code>class EmailSender {
    send(to, subject, body) {
        // Hides SMTP complexity
        this.#connect();
        this.#authenticate();
        this.#sendMessage(to, subject, body);
        this.#disconnect();
    }
}</code></pre></li>
</ol>
<h3 id="2-rest-api-communication">2. REST API Communication</h3>
<p><strong>What is REST?</strong> REST (Representational State Transfer)
is a pattern for client-server communication:</p>
<pre><code>Client (Browser)          Server (Flask)
     |                         |
     |---- GET /cities -------&gt;|
     |                         |
     |&lt;--- 200 OK + JSON ------|
     |    [{id:1, name:&quot;...&quot;}] |</code></pre>
<p><strong>HTTP Methods:</strong></p>
<pre class="javascript"><code>GET     /cities        // Read all cities
GET     /cities/1      // Read one city
POST    /cities        // Create new city
PUT     /cities/1      // Update city
DELETE  /cities/1      // Delete city</code></pre>
<p><strong>Our Flask Endpoints:</strong></p>
<pre class="python"><code>POST /add       # Add new city
POST /all       # Get all cities
POST /read      # Get city by key
POST /update    # Update city
POST /delete    # Delete city
GET  /clear     # Clear all data</code></pre>
<h3 id="3-asyncawait-pattern">3. Async/Await Pattern</h3>
<p><strong>The Problem: Callback Hell (2015)</strong></p>
<pre class="javascript"><code>// Old way - nested callbacks
fetchData(url, function(data) {
    processData(data, function(result) {
        saveData(result, function(response) {
            console.log(&#39;Done!&#39;);  // Deeply nested!
        });
    });
});</code></pre>
<p><strong>The Solution: Async/Await (2025)</strong></p>
<pre class="javascript"><code>// Modern way - linear code
async function workflow() {
    const data = await fetchData(url);
    const result = await processData(data);
    const response = await saveData(result);
    console.log(&#39;Done!&#39;);  // Readable!
}</code></pre>
<p><strong>How It Works:</strong></p>
<pre class="javascript"><code>// 1. Mark function as async
async function getCities() {
    // 2. Use await for promises
    const response = await fetch(&#39;/api/cities&#39;);
    const data = await response.json();
    return data;
}

// 3. Call async function
getCities().then(cities =&gt; console.log(cities));</code></pre>
<hr />
<h2 id="code-walkthrough">Code Walkthrough</h2>
<h3 id="file-structure">File Structure</h3>
<pre><code>03-objects/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ account.js          # Bank account class
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ account.test.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ geography.js        # ‚≠ê City/Community classes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ geography.test.js   # ‚≠ê Integration tests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fetch.js            # ‚≠ê API utilities
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fetch.test.js
‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ jest.config.js              # jsdom + node-fetch config
‚îú‚îÄ‚îÄ jest.setup.js               # TextEncoder polyfill
‚îî‚îÄ‚îÄ package.json</code></pre>
<h3 id="accountjs---bank-account-system">account.js - Bank Account
System</h3>
<pre class="javascript"><code>class Account {
    constructor(name, balance = 0) {
        this.name = name;
        this.balance = balance;
    }

    // Deposit money
    deposit(amount) {
        if (amount &gt; 0) {
            this.balance += amount;
        }
        return this.balance;
    }

    // Withdraw money
    withdraw(amount) {
        if (amount &gt; 0 &amp;&amp; amount &lt;= this.balance) {
            this.balance -= amount;
        }
        return this.balance;
    }

    // Display account info
    display() {
        return `${this.name}: $${this.balance}`;
    }

    // Validate new balance
    isNewAmount(newBalance) {
        if (typeof newBalance !== &#39;number&#39;) {
            return &#39;ERROR: Not a number&#39;;
        }
        if (newBalance &lt; 0) {
            return &#39;ERROR: Negative balance&#39;;
        }
        this.balance = newBalance;
        return this.balance;
    }
}

export default Account;</code></pre>
<p><strong>Design Decisions:</strong></p>
<ol type="1">
<li><strong>Default Parameters</strong>: <code>balance = 0</code> allows
creating accounts without initial balance</li>
<li><strong>Guard Clauses</strong>: Check conditions before modifying
state</li>
<li><strong>Return Values</strong>: Methods return new balance for
chaining/verification</li>
<li><strong>Validation</strong>: <code>isNewAmount</code> prevents
invalid states</li>
</ol>
<p><strong>Real-World Usage:</strong></p>
<pre class="javascript"><code>const myAccount = new Account(&#39;Brennan&#39;, 1000);
myAccount.deposit(500);      // $1500
myAccount.withdraw(200);     // $1300
myAccount.display();         // &quot;Brennan: $1300&quot;</code></pre>
<h3 id="geographyjs---city-class">geography.js - City Class</h3>
<pre class="javascript"><code>class City {
    constructor(name, population, latitude, longitude, key) {
        this.name = name;
        this.population = population;
        this.latitude = latitude;
        this.longitude = longitude;
        this.key = key;
    }

    // Display city information
    show() {
        return `${this.name}, population: ${this.population}`;
    }

    // Population movement methods
    transferIn(amount) {
        this.population += amount;
        return this.population;
    }

    transferOut(amount) {
        this.population -= amount;
        return this.population;
    }

    // Determine hemisphere
    whichHemiphere() {
        if (this.latitude &gt; 0) return &#39;Northern Hemisphere&#39;;
        if (this.latitude &lt; 0) return &#39;Southern Hemisphere&#39;;
        return &#39;Equator&#39;;
    }

    // Classify city by population
    classification() {
        const pop = this.population;
        
        if (pop &lt; 100) return &#39;Hamlet&#39;;
        if (pop &lt; 1000) return &#39;Village&#39;;
        if (pop &lt; 20000) return &#39;Town&#39;;
        if (pop &lt; 100000) return &#39;Large Town&#39;;
        if (pop &gt;= 100000) return &#39;City&#39;;  // ‚ö†Ô∏è BUG WAS HERE: used &gt;
        
        return &#39;ERROR&#39;;
    }
}

export default City;</code></pre>
<p><strong>Why These Methods?</strong></p>
<ul>
<li><strong>transferIn/Out</strong>: Model population migration</li>
<li><strong>whichHemiphere</strong>: Demonstrate conditional logic on
instance data</li>
<li><strong>classification</strong>: Graduated thresholds (like tax
brackets!)</li>
</ul>
<h3 id="geographyjs---community-class-complex">geography.js - Community
Class (Complex!)</h3>
<pre class="javascript"><code>import functions from &#39;./fetch.js&#39;;

class Community {
    constructor() {
        this.url = &#39;http://localhost:5002/&#39;;
        this.community = [];
    }

    /**
     * Create a new city and store it on the server
     * ‚ö†Ô∏è This method had THE MOST bugs!
     */
    async createCity(city, latitude, longitude, population) {
        try {
            // 1. Get all existing cities to determine next key
            let data = await functions.postData(this.url + &#39;all&#39;);
            let i;
            
            if (data.length === 0) {
                i = 0;  // First city
            } else {
                // Find highest key
                i = data.sort((a, b) =&gt; b.key - a.key);
                i = i[0].key;
            }
            
            // 2. Create new city with next key
            // ‚ö†Ô∏è BUG WAS HERE: Parameter order was wrong!
            let myCity = new City(city, population, latitude, longitude, i + 1);
            
            // 3. Send to server
            data = await functions.postData(this.url + &#39;add&#39;, myCity);
            
            if (data.status === 200) {
                return data;
            }
            return &#39;SERVER ERROR&#39;;
        } catch (error) {
            console.error(&quot;Error:&quot;, error);
        }
    }

    /**
     * Get all cities from server
     */
    async getCommunity() {
        try {
            let data = await functions.postData(this.url + &#39;all&#39;);
            
            if (data.length &gt; 0) {
                this.community = await JSON.parse(JSON.stringify(data));
                return this.community;
            }
            return &#39;SERVER ERROR&#39;;
        } catch (error) {
            console.error(&quot;Error:&quot;, error);
        }
    }

    /**
     * Get most northern city
     */
    getMostNorthern() {
        let data = this.community;
        if (data.length === 0) return &#39;ERROR&#39;;
        
        data.sort((a, b) =&gt; b.latitude - a.latitude);
        return data[0].name;
    }

    /**
     * Get most southern city
     */
    getMostSouthern() {
        let data = this.community;
        if (data.length === 0) return &#39;ERROR&#39;;
        
        data.sort((a, b) =&gt; a.latitude - b.latitude);
        return data[0].name;
    }

    /**
     * Calculate total population
     */
    async getTotalPopulation() {
        try {
            let data = await functions.postData(this.url + &#39;all&#39;);
            
            if (data.length &gt; 0) {
                let population = data.map(city =&gt; city.population);
                population = population.reduce((a, b) =&gt; Number(a) + Number(b));
                return Number(population).toLocaleString();
            }
            return &#39;ERROR&#39;;
        } catch (error) {
            console.error(&quot;Error:&quot;, error);
        }
    }

    /**
     * Update city population on server
     */
    async updatePopulation(city) {
        try {
            // ‚ö†Ô∏è BUG WAS HERE: Had unnecessary /all check
            let data = await functions.postData(this.url + &#39;update&#39;, {
                key: city.key,
                name: city.name,
                latitude: city.latitude,
                longitude: city.longitude,
                population: city.population
            });
            
            if (data.status === 200) {
                return data;
            }
            return &#39;SERVER ERROR&#39;;
        } catch (error) {
            console.error(&quot;Error:&quot;, error);
        }
    }

    /**
     * Delete city from server
     */
    async deleteCity(key) {
        try {
            let data = await functions.postData(this.url + &#39;delete&#39;, { key: key });
            
            if (data.status === 200) {
                return data;
            }
            return &#39;SERVER ERROR&#39;;
        } catch (error) {
            console.error(&quot;Error:&quot;, error);
        }
    }
}

export { City, Community };</code></pre>
<hr />
<h2 id="api-integration">API Integration</h2>
<h3 id="fetchjs---api-utility-functions">fetch.js - API Utility
Functions</h3>
<pre class="javascript"><code>const functions = {
    url: &quot;http://127.0.0.1:5002/&quot;,

    /**
     * Make POST request to server
     * Handles both array and object responses
     */
    async postData(url = &quot;&quot;, info = {}) {
        const response = await fetch(url, {
            method: &quot;POST&quot;,
            headers: {
                &quot;Content-Type&quot;: &quot;application/json&quot;,
                &quot;Accept&quot;: &quot;application/json&quot;
            },
            body: JSON.stringify(info)
        });
        
        const text = await response.text();
        
        // ‚ö†Ô∏è BUG WAS HERE: Empty responses caused JSON.parse to fail
        let JSON_DATA = text ? JSON.parse(text) : {};
        
        // If it&#39;s an array, just return it (for /all endpoint)
        if (Array.isArray(JSON_DATA)) {
            return JSON_DATA;
        }
        
        // For objects, add status information
        JSON_DATA.status = response.status;
        JSON_DATA.statusText = response.statusText;
        return JSON_DATA;
    },

    /**
     * Extract first names from array of objects
     */
    retrieveAllNames(info) {
        try {
            return info.map(person =&gt; person.first_name);
        } catch (error) {
            console.error(&quot;Error:&quot;, error);
        }
    }
};

export default functions;</code></pre>
<p><strong>Critical Design Decisions:</strong></p>
<ol type="1">
<li><p><strong>Why differentiate array vs object responses?</strong></p>
<pre class="javascript"><code>// /all endpoint returns array: [city1, city2, ...]
// /add endpoint returns object: {status: 200, ...}

// Need to handle both!
if (Array.isArray(JSON_DATA)) {
    return JSON_DATA;  // No status needed for arrays
}</code></pre></li>
<li><p><strong>Why parse empty text?</strong></p>
<pre class="javascript"><code>// Some endpoints return empty body with 200 status
const text = await response.text();
let JSON_DATA = text ? JSON.parse(text) : {};</code></pre></li>
<li><p><strong>Why add status to response?</strong></p>
<pre class="javascript"><code>// Tests need to verify status codes
JSON_DATA.status = response.status;  // 200, 400, etc.</code></pre></li>
</ol>
<h3 id="flask-backend-webpy">Flask Backend (web.py)</h3>
<pre class="python"><code>from flask import Flask, request, jsonify
from flask_cors import CORS

app = Flask(__name__)
CORS(app)  # Allow requests from browser

data = {}
firstKeyType = None

@app.route(&quot;/add&quot;, methods=[&#39;POST&#39;])
def add():
    global data, firstKeyType
    
    # Get data from request
    req = request.get_json()
    key = req.get(&#39;key&#39;)
    
    # Check if key already exists
    if key in data:
        return jsonify({}), 400  # Bad request
    
    # Store data
    data[key] = req
    return jsonify({}), 200

@app.route(&quot;/all&quot;, methods=[&#39;POST&#39;, &#39;GET&#39;])
def get_all():
    # Return all data as array
    return jsonify(list(data.values())), 200

@app.route(&quot;/update&quot;, methods=[&#39;POST&#39;])
def update():
    req = request.get_json()
    key = req.get(&#39;key&#39;)
    
    if key not in data:
        return jsonify({}), 400
    
    data[key] = req
    return jsonify({}), 200

@app.route(&quot;/delete&quot;, methods=[&#39;POST&#39;])
def delete():
    req = request.get_json()
    key = req.get(&#39;key&#39;)
    
    if key not in data:
        return jsonify({}), 400
    
    del data[key]
    return jsonify({}), 200

@app.route(&quot;/clear&quot;, methods=[&#39;POST&#39;, &#39;GET&#39;])
def clear():
    global data, firstKeyType
    data = {}
    firstKeyType = None  # ‚ö†Ô∏è BUG WAS HERE: Didn&#39;t reset this
    return jsonify(data), 200

if __name__ == &#39;__main__&#39;:
    print(&quot;--- Starting&quot;, __file__)
    # ‚ö†Ô∏è Changed: debug=False to prevent hanging
    app.run(debug=False, use_reloader=False, port=5002)</code></pre>
<hr />
<h2 id="testing-strategy">Testing Strategy</h2>
<h3 id="integration-test-setup">Integration Test Setup</h3>
<pre class="javascript"><code>// geography.test.js
import { City, Community } from &quot;./geography.js&quot;
import functions from &quot;./fetch.js&quot;
import fetch from &quot;node-fetch&quot;;

// Use real fetch for integration tests
global.fetch = fetch;
const url = &quot;http://localhost:5002/&quot;;

// Clear data before each test
beforeEach(async () =&gt; {
    await fetch(url + &quot;clear&quot;);
    await new Promise(resolve =&gt; setTimeout(resolve, 50));
})</code></pre>
<p><strong>Why this setup?</strong></p>
<ol type="1">
<li><strong>node-fetch</strong>: Jest runs in Node.js, not browser‚Äîneed
fetch polyfill</li>
<li><strong>beforeEach</strong>: Ensures clean state for every test</li>
<li><strong>setTimeout</strong>: Small delay lets Flask process clear
request</li>
<li><strong>Integration</strong>: Tests full stack, not just
JavaScript</li>
</ol>
<h3 id="jest-configuration">Jest Configuration</h3>
<pre class="javascript"><code>// jest.config.js
module.exports = {
  testEnvironment: &#39;jsdom&#39;,           // Simulate browser
  setupFiles: [&#39;&lt;rootDir&gt;/jest.setup.js&#39;],  // Global setup
  maxWorkers: 1,                      // Run tests serially
  transformIgnorePatterns: [
    &#39;node_modules/(?!(node-fetch)/)&#39;  // Transpile node-fetch
  ],
};

// jest.setup.js
const { TextDecoder, TextEncoder } = require(&#39;util&#39;);
global.TextDecoder = TextDecoder;
global.TextEncoder = TextEncoder;</code></pre>
<h3 id="sample-tests">Sample Tests</h3>
<pre class="javascript"><code>test(&quot;Does the createCity function work?&quot;, async () =&gt; {
    const community = new Community;
    
    // Create first city
    let info = await community.createCity(&quot;Chestermere&quot;, 51.0382, 113.8425, 19887);
    expect(info.status).toBe(200);
    
    // Create second city
    info = await community.createCity(&quot;Winnipeg&quot;, 49.895138, 97.138374, 749534);
    expect(info.status).toBe(200);
});

test(&quot;Does the getTotalPopulation function work?&quot;, async () =&gt; {
    const community = new Community;
    
    await community.createCity(&quot;Gadsby&quot;, 52.2954, 112.3564, 40);
    await community.createCity(&quot;Rainbow Lake&quot;, 58.4999, 119.3996, 795);
    
    expect(await community.getTotalPopulation()).toBe(&quot;835&quot;);
});

test(&quot;Does the updatePopulation function work?&quot;, async () =&gt; {
    const community = new Community;
    
    // Create city with 749,534 population
    let info = await community.createCity(&quot;Winnipeg&quot;, 49.895138, 97.138374, 749534);
    info = await community.getCommunity();
    
    // Get the city from server
    let serverCity = info[0];
    let testCity = new City(
        serverCity.name,
        serverCity.population,
        serverCity.latitude,
        serverCity.longitude,
        serverCity.key
    );
    
    // Add 100,000 people
    testCity.transferIn(100000);
    
    // Update server
    await community.updatePopulation(testCity);
    
    // Verify update worked
    let update = await community.getCommunity();
    expect(update[0].population).toBe(849534);
});</code></pre>
<hr />
<h2 id="bugs-fixed">Bugs Fixed</h2>
<p>This module had <strong>14 bugs</strong>‚Äîthe most of any module! Let
me detail the critical ones:</p>
<h3 id="bug-1-city-constructor-parameter-order">Bug #1: City Constructor
Parameter Order</h3>
<pre class="javascript"><code>// ‚ùå WRONG: createCity passes parameters in wrong order
async createCity(city, latitude, longitude, population) {
    let myCity = new City(city, latitude, longitude, population, key);
    //                         ‚Üë         ‚Üë          ‚Üë
    //                      WRONG     WRONG      WRONG
}

// ‚úÖ CORRECT: Match City constructor signature
async createCity(city, latitude, longitude, population) {
    let myCity = new City(city, population, latitude, longitude, key);
    //                         ‚Üë           ‚Üë          ‚Üë
    //                      RIGHT       RIGHT      RIGHT
}</code></pre>
<p><strong>Impact:</strong> Cities were created with latitude as
population and vice versa!</p>
<h3 id="bug-2-updatepopulation-unnecessary-check">Bug #2:
updatePopulation Unnecessary Check</h3>
<pre class="javascript"><code>// ‚ùå WRONG: Checks /all status, but /all returns array!
async updatePopulation(city) {
    let data = await functions.postData(this.url + &#39;all&#39;);
    if (data.status === 200) {  // Arrays don&#39;t have .status!
        // This never runs!
    }
}

// ‚úÖ CORRECT: Remove unnecessary check
async updatePopulation(city) {
    let data = await functions.postData(this.url + &#39;update&#39;, cityData);
    if (data.status === 200) {  // Now checking the right response
        return data;
    }
}</code></pre>
<p><strong>Impact:</strong> Updates never executed because condition
always failed.</p>
<h3 id="bug-3-classification-threshold">Bug #3: Classification
Threshold</h3>
<pre class="javascript"><code>// ‚ùå WRONG: City classification uses &gt; instead of &gt;=
if (pop &gt; 100000) return &#39;City&#39;;

// Results: 100,000 population returns undefined!

// ‚úÖ CORRECT: Use &gt;=
if (pop &gt;= 100000) return &#39;City&#39;;</code></pre>
<p><strong>Impact:</strong> Cities with exactly 100,000 people fell
through all conditions.</p>
<h3 id="bug-4-empty-json-response-handling">Bug #4: Empty JSON Response
Handling</h3>
<pre class="javascript"><code>// ‚ùå WRONG: Fails when response is empty
const json = await response.json();  // Throws on empty body!

// ‚úÖ CORRECT: Handle empty responses
const text = await response.text();
const json = text ? JSON.parse(text) : {};</code></pre>
<p><strong>Impact:</strong> Crashed when Flask returned 200 with empty
body.</p>
<h3 id="bug-5-array-vs-object-response">Bug #5: Array vs Object
Response</h3>
<pre class="javascript"><code>// ‚ùå WRONG: Always adds status, even to arrays
let JSON_DATA = await response.json();
JSON_DATA.status = response.status;  // Adds to array!

// Result: [{city}, {city}].status = 200 (weird!)

// ‚úÖ CORRECT: Only add status to objects
if (Array.isArray(JSON_DATA)) {
    return JSON_DATA;  // Arrays don&#39;t need status
} else {
    JSON_DATA.status = response.status;
    return JSON_DATA;
}</code></pre>
<p><strong>Impact:</strong> Tests failed because
<code>data.status</code> was undefined for array responses.</p>
<h3 id="bug-6-port-5000-conflict">Bug #6: Port 5000 Conflict</h3>
<pre class="javascript"><code>// ‚ùå WRONG: Port 5000 is used by macOS ControlCenter!
url: &quot;http://127.0.0.1:5000/&quot;  // Connection refused!

// ‚úÖ CORRECT: Use port 5002
url: &quot;http://127.0.0.1:5002/&quot;</code></pre>
<p><strong>Impact:</strong> Fetch requests returned 403 Forbidden from
system service.</p>
<h3 id="bug-7-flask-clear-endpoint">Bug #7: Flask Clear Endpoint</h3>
<pre class="python"><code># ‚ùå WRONG: Doesn&#39;t reset firstKeyType
@app.route(&quot;/clear&quot;)
def clear():
    global data
    data = {}
    return jsonify(data), 200

# ‚úÖ CORRECT: Reset all global state
@app.route(&quot;/clear&quot;)
def clear():
    global data, firstKeyType
    data = {}
    firstKeyType = None  # Must reset this too!
    return jsonify(data), 200</code></pre>
<p><strong>Impact:</strong> State leaked between tests, causing
unpredictable failures.</p>
<hr />
<h2 id="2021-vs-2025-comparison">2021 vs 2025 Comparison</h2>
<h3 id="async-patterns">Async Patterns</h3>
<p><strong>2021: Promises &amp; Callbacks</strong></p>
<pre class="javascript"><code>// Old way - promise chains
function getCities() {
    return fetch(url)
        .then(response =&gt; response.json())
        .then(data =&gt; {
            return processData(data);
        })
        .then(result =&gt; {
            return saveResult(result);
        })
        .catch(error =&gt; {
            console.error(error);
        });
}</code></pre>
<p><strong>2025: Async/Await</strong></p>
<pre class="javascript"><code>// Modern way - sequential syntax
async function getCities() {
    try {
        const response = await fetch(url);
        const data = await response.json();
        const result = await processData(data);
        return await saveResult(result);
    } catch (error) {
        console.error(error);
    }
}</code></pre>
<h3 id="class-syntax">Class Syntax</h3>
<p><strong>2021: Constructor Functions</strong></p>
<pre class="javascript"><code>// Old way - function constructors
function City(name, population) {
    this.name = name;
    this.population = population;
}

City.prototype.show = function() {
    return this.name;
};</code></pre>
<p><strong>2025: ES6 Classes</strong></p>
<pre class="javascript"><code>// Modern way - class keyword
class City {
    constructor(name, population) {
        this.name = name;
        this.population = population;
    }
    
    show() {
        return this.name;
    }
}</code></pre>
<h3 id="module-system">Module System</h3>
<p><strong>2021: CommonJS</strong></p>
<pre class="javascript"><code>// Old way
const City = require(&#39;./city&#39;);
module.exports = City;</code></pre>
<p><strong>2025: ES6 Modules</strong></p>
<pre class="javascript"><code>// Modern way
import { City } from &#39;./city.js&#39;;
export { City };</code></pre>
<h3 id="cors-handling">CORS Handling</h3>
<p><strong>2021: Manual CORS</strong></p>
<pre class="javascript"><code>// Old way - lots of options
fetch(url, {
    method: &#39;POST&#39;,
    mode: &#39;cors&#39;,
    cache: &#39;no-cache&#39;,
    credentials: &#39;same-origin&#39;,
    headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
    redirect: &#39;follow&#39;,
    referrer: &#39;no-referrer&#39;,
    body: JSON.stringify(data)
});</code></pre>
<p><strong>2025: Simplified</strong></p>
<pre class="javascript"><code>// Modern way - just the essentials
fetch(url, {
    method: &#39;POST&#39;,
    headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
    body: JSON.stringify(data)
});</code></pre>
<hr />
<h2 id="key-takeaways">Key Takeaways</h2>
<h3 id="technical-skills">Technical Skills</h3>
<ol type="1">
<li><strong>OOP Mastery</strong>: Classes, inheritance,
encapsulation</li>
<li><strong>Async Programming</strong>: Promise handling, error
management</li>
<li><strong>REST APIs</strong>: HTTP methods, status codes, JSON</li>
<li><strong>Full-Stack Integration</strong>: Client-server
architecture</li>
<li><strong>Test-Driven Development</strong>: Integration testing</li>
</ol>
<h3 id="architecture-patterns">Architecture Patterns</h3>
<p><strong>Pattern 1: Repository Pattern</strong></p>
<pre class="javascript"><code>class CityRepository {
    async getAll() { return await fetch(&#39;/api/cities&#39;); }
    async getOne(id) { return await fetch(`/api/cities/${id}`); }
    async create(city) { return await fetch(&#39;/api/cities&#39;, {...}); }
    async update(city) { return await fetch(`/api/cities/${city.id}`, {...}); }
    async delete(id) { return await fetch(`/api/cities/${id}`, {method: &#39;DELETE&#39;}); }
}</code></pre>
<p><strong>Pattern 2: Facade Pattern</strong></p>
<pre class="javascript"><code>// Hide complex API calls behind simple interface
class Community {
    async addCity(name, lat, lng, pop) {
        // Internally: fetch all, calculate key, create city, post to server
        // Externally: just call one method
    }
}</code></pre>
<p><strong>Pattern 3: Error Handling</strong></p>
<pre class="javascript"><code>async function safeApiCall() {
    try {
        const data = await riskyOperation();
        return data;
    } catch (error) {
        console.error(&#39;Operation failed:&#39;, error);
        return &#39;ERROR&#39;;  // Graceful degradation
    }
}</code></pre>
<h3 id="debugging-lessons">Debugging Lessons</h3>
<ol type="1">
<li><strong>Parameter Order Matters</strong>: Use named parameters for
clarity</li>
<li><strong>Type Checking</strong>: Arrays vs Objects need different
handling</li>
<li><strong>Port Conflicts</strong>: Check system services (lsof -i
:port)</li>
<li><strong>State Management</strong>: Clear global state between
tests</li>
<li><strong>Response Handling</strong>: Always check for empty
responses</li>
</ol>
<hr />
<h2 id="further-learning">Further Learning</h2>
<h3 id="practice-exercises">Practice Exercises</h3>
<ol type="1">
<li><p><strong>Extend City Class:</strong></p>
<ul>
<li>Add <code>timezone</code> property</li>
<li>Implement <code>distanceTo(otherCity)</code> method</li>
<li>Add <code>nearestNeighbor()</code> functionality</li>
</ul></li>
<li><p><strong>Add Features:</strong></p>
<ul>
<li>Search cities by name</li>
<li>Filter by population range</li>
<li>Sort by multiple criteria</li>
<li>Paginate results</li>
</ul></li>
<li><p><strong>Error Handling:</strong></p>
<ul>
<li>Retry failed requests</li>
<li>Implement timeout logic</li>
<li>Add loading states</li>
<li>Handle network errors gracefully</li>
</ul></li>
</ol>
<h3 id="real-world-applications">Real-World Applications</h3>
<ul>
<li><strong>Social Media</strong>: User management, posts, comments</li>
<li><strong>E-commerce</strong>: Products, cart, orders</li>
<li><strong>Mapping</strong>: Locations, routes, POIs</li>
<li><strong>CRM</strong>: Contacts, companies, deals</li>
</ul>
<h3 id="recommended-resources">Recommended Resources</h3>
<ul>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">MDN
Fetch API</a></li>
<li><a href="https://javascript.info/class">JavaScript Classes</a></li>
<li><a href="https://restfulapi.net/">REST API Design</a></li>
<li><a href="https://javascript.info/async-await">Async/Await
Tutorial</a></li>
</ul>
<h3 id="next-module">Next Module</h3>
<p>Now that we understand full-stack integration, we're ready for
<strong>modern frontend frameworks</strong> in <a
href="./04-react.md">Module 04: React Applications</a> ‚Üí</p>
<hr />
<p><strong>Module Status:</strong> ‚úÖ Complete (30/30 tests
passing)<br />
<strong>Key Bugs Fixed:</strong> 14 (parameter order, response handling,
port conflicts)<br />
<strong>Time Investment:</strong> ~8 hours (most complex module)<br />
<strong>Key Achievement:</strong> Built first full-stack application
with working API integration!</p>
            </article>
        </main>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-grid">
                <div class="footer-col">
                    <h4>EvolveU Documentation</h4>
                    <p>Comprehensive full-stack web development bootcamp documentation.</p>
                </div>
                <div class="footer-col">
                    <h4>Links</h4>
                    <ul class="footer-links">
                        <li><a href="https://brennanbrown.ca" target="_blank">Portfolio</a></li>
                        <li><a href="https://brennanbrown.ca/Resume.pdf" target="_blank">Resume</a></li>
                        <li><a href="https://github.com/brennanbrown" target="_blank">GitHub</a></li>
                        <li><a href="https://berryhouse.ca" target="_blank">BerryHouse</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Brennan Brown. Built with ‚ù§Ô∏è for the developer community.</p>
            </div>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="script.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
